{"version":3,"sources":["../yjs/node_modules/browserify/node_modules/browser-pack/_prelude.js","src/Richtext.js","y-richtext.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","extend","Y","requestModules","then","YRichtext","_Y$Array$typeDefiniti","os","_model","_content","this","_this","getPrototypeOf","instances","_createClass","key","unbindQuill","editor","_get","map","v","val","join","createNewOp","attrs","name","op","attributes","insert","ops","Array","push","pos","content","curPos","selection","split","curSel","endPos","delStart","delEnd","rightSel","undefined","end","from","to","attrName","attrValue","step2i","step2sel","antiAttrs","_v","deletes","_v2","j","del","performStep4","sel","delta","_quill","select","retain","afterRetain","additionalContent","getText","insertText","formatText","bindQuill","apply","arguments","quill","findIndex","binding","unobserve","yCallback","off","quillCallback","splice","mutualExcluse","token","applyDelta","event","type","_value_i","values","vals","position","insertSel","index","newSel","selectionStart","selectionEnd","k","myEvents","_i","forEach","deleteText","x","checkUpdate","setContents","toDelta","on","observe","regeneratorRuntime","mark","_changed","_args","wrap","_context","prev","next","delegateYield","typeDefinition","stop","get","toString","utils","CustomType","class","struct","initType","YTextInitializer","model","_context2","Struct","List","hasOwnProperty","c","id","abrupt","defineProperties","target","props","descriptor","defineProperty","protoProps","staticProps","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getter"],"mappings":"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","file":"y-richtext.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['Array']).then(function () {\n    class YRichtext extends Y.Array.typeDefinition['class'] {\n      constructor (os, _model, _content) {\n        super(os, _model, _content)\n        this.instances = []\n      }\n      _destroy () {\n        for (var i = this.instances.length - 1; i >= 0; i--) {\n          this.unbindQuill(this.instances[i].editor)\n        }\n        super._destroy()\n      }\n      get length () {\n        /*\n          TODO: I must not use observe to compute the length.\n          But since I inherit from Y.Array, I can't set observe\n          the changes at the right momet (for that I would require direct access to EventHandler).\n          This is the most elegant solution, for now.\n          But at some time you should re-write Y.Richtext more elegantly!!\n        */\n        return this.toString().length\n      }\n      toString () {\n        return this._content.map(function (v) {\n          if (typeof v.val === 'string') {\n            return v.val\n          }\n        }).join('')\n      }\n      toDelta () {\n        var ops = []\n        var op = {\n          insert: [],\n          attributes: {}\n        }\n        function createNewOp () {\n          var attrs = {}\n          // copy attributes\n          for (var name in op.attributes) {\n            attrs[name] = op.attributes[name]\n          }\n          op = {\n            insert: [],\n            attributes: attrs\n          }\n        }\n        var i = 0\n        for (; i < this._content.length; i++) {\n          let v = this._content[i].val\n          if (v.constructor === Array) {\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            if (v[1] === null) {\n              delete op.attributes[v[0]]\n            } else {\n              op.attributes[v[0]] = v[1]\n            }\n          } else {\n            op.insert.push(v)\n          }\n        }\n        if (op.insert.length > 0) {\n          op.insert = op.insert.join('')\n          ops.push(op)\n        }\n        return ops\n      }\n      insert (pos, content) {\n        var curPos = 0\n        var selection = {}\n        for (var i = 0; i < this._content.length; i++) {\n          if (curPos === pos) {\n            break\n          }\n          var v = this._content[i].val\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            if (v[1] === null) {\n              delete selection[v[0]]\n            } else {\n              selection[v[0]] = v[1]\n            }\n          }\n        }\n        super.insert(i, content.split(''))\n        return selection\n      }\n      delete (pos, length) {\n        /*\n          let x = to be deleted string\n          let s = some string\n          let * = some selection\n          E.g.\n          sss*s***x*xxxxx***xx*x**ss*s\n               |---delete-range--|\n             delStart         delEnd\n\n          We'll check the following\n          * is it possible to delete some of the selections?\n            1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n            2. a selections could be overwritten by another selection to the right\n        */\n        var curPos = 0\n        var curSel = {}\n        var endPos = pos + length\n        if (length <= 0) return\n        var delStart // relative to _content\n        var delEnd // ..\n        var v, i // helper variable for elements of _content\n\n        for (delStart = 0; curPos < pos && delStart < this._content.length; delStart++) {\n          v = this._content[delStart].val\n          if (typeof v === 'string') {\n            curPos++\n          } else if (v.constructor === Array) {\n            curSel[v[0]] = v[1]\n          }\n        }\n        for (delEnd = delStart; curPos < endPos && delEnd < this._content.length; delEnd++) {\n          v = this._content[delEnd].val\n          if (typeof v === 'string') {\n            curPos++\n          }\n        }\n        if (delEnd === this._content.length) {\n          // yay, you can delete everything without checking\n          super.delete(delStart, delEnd - delStart)\n        } else {\n          if (typeof v === 'string') {\n            delEnd--\n          }\n          var rightSel = {}\n          for (i = delEnd; i >= delStart; i--) {\n            v = this._content[i].val\n            if (v.constructor === Array) {\n              if (rightSel[v[0]] === undefined) {\n                if (v[1] === curSel[v[0]]) {\n                  // case 1.\n                  super.delete(i, 1)\n                }\n                rightSel[v[0]] = v[1]\n              } else {\n                // case 2.\n                super.delete(i, 1)\n              }\n            } else if (typeof v === 'string') {\n              var end = i + 1\n              while (i > delStart) {\n                v = this._content[i - 1].val\n                if (typeof v === 'string') {\n                  i--\n                } else {\n                  break\n                }\n              }\n              // always delete the strings\n              super.delete(i, end - i)\n            }\n          }\n        }\n      }\n      /*\n      1. get selection attributes from position $from\n         (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n      2. Insert selection $attr, if necessary\n      3. Between from and to, we'll delete all selections that do not match $attr.\n         Furthermore, we'll update antiAttrs, if necessary\n      4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs\n      */\n      select (from, to, attrName, attrValue) {\n        if (from == null || to == null || attrName == null || attrValue === undefined) {\n          throw new Error('You must define four parameters')\n        } else {\n          var step2i\n          var step2sel\n          var antiAttrs = [attrName, null]\n          var curPos = 0\n          var i = 0\n          // 1. compute antiAttrs\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === from) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // 2. Insert attr\n          if (antiAttrs[1] !== attrValue) {\n            // we'll execute this later\n            step2i = i\n            step2sel = [attrName, attrValue]\n          }\n\n          // 3. update antiAttrs, modify selection\n          var deletes = []\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === to) {\n              break\n            }\n            if (v.constructor === Array) {\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n                deletes.push(i)\n              }\n            } else if (typeof v === 'string') {\n              curPos++\n            }\n          }\n          // actually delete the found selections\n          // also.. we have to delete from right to left (so that the positions dont change)\n          for (var j = deletes.length - 1; j >= 0; j--) {\n            var del = deletes[j]\n            super.delete(del, 1)\n            // update i, rel. to\n            if (del < i) {\n              i--\n            }\n            if (del < step2i) {\n              step2i--\n            }\n          }\n          // 4. Update selection to match antiAttrs\n          // never insert, if not necessary\n          //  1. when it is the last position ~ i < _content.length)\n          //  2. when a similar attrName already exists between i and the next character\n          if (antiAttrs[1] !== attrValue && i < this._content.length) { // check 1.\n            var performStep4 = true\n            var v\n            for (j = i; j < this._content.length; j++) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                performStep4 = false // check 2.\n                if (v[1] === attrValue) {\n                  super.delete(j, 1)\n                }\n                break\n              }\n            }\n            if (performStep4) {\n              var sel = [attrName, antiAttrs[1]]\n              super.insert(i, [sel])\n            }\n          }\n          if (step2i != null) {\n            super.insert(step2i, [step2sel])\n            // if there are some selections to the left of step2sel, delete them if possible\n            // * have same attribute name\n            // * no insert between step2sel and selection\n            for (j = step2i - 1; j >= 0; j--) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                super.delete(j, 1)\n              }\n            }\n          }\n        }\n      }\n      /*\n        This method accepts a quill delta (http://quilljs.com/docs/deltas/)\n        The second parameter (_quill) is optional (it is only necessary when binding a quill instance)\n      */\n      applyDelta (delta, _quill) {\n        var pos = 0\n        var name // helper variable\n        for (var i = 0; i < delta.ops.length; i++) {\n          var op = delta.ops[i]\n          if (op.insert != null) {\n            var attrs = this.insert(pos, op.insert)\n            // create new selection\n            for (name in op.attributes) {\n              if (op.attributes[name] !== attrs[name]) {\n                this.select(pos, pos + op.insert.length, name, op.attributes[name])\n              }\n            }\n            // not-existence of an attribute in op.attributes denotes\n            // that we have to unselect (set to null)\n            for (name in attrs) {\n              if (op.attributes == null || attrs[name] !== op.attributes[name]) {\n                this.select(pos, pos + op.insert.length, name, null)\n              }\n            }\n            pos += op.insert.length\n          }\n          if (op.delete != null) {\n            this.delete(pos, op.delete)\n          }\n          if (op.retain != null && _quill != null) {\n            var afterRetain = pos + op.retain\n            if (afterRetain > this.length) {\n              let additionalContent = _quill.getText(this.length)\n              _quill.insertText(this.length, additionalContent)\n              // quill.deleteText(this.length + additionalContent.length, quill.getLength())\n              for (name in op.attributes) {\n                _quill.formatText(this.length + additionalContent.length, this.length + additionalContent.length * 2, name, null)\n                // quill.deleteText(this.length, this.length + op.retain)\n              }\n              this.insert(this.length, additionalContent)\n              // op.attributes = null\n            }\n            for (name in op.attributes) {\n              this.select(pos, pos + op.retain, name, op.attributes[name])\n              _quill.formatText(pos, pos + op.retain, name, op.attributes[name])\n            }\n            pos = afterRetain\n          }\n        }\n      }\n      bind () {\n        this.bindQuill.apply(this, arguments)\n      }\n      unbindQuill (quill) {\n        var i = this.instances.findIndex(function (binding) {\n          return binding.editor === quill\n        })\n        if (i >= 0) {\n          var binding = this.instances[i]\n          this.unobserve(binding.yCallback)\n          binding.editor.off('text-change', binding.quillCallback)\n          this.instances.splice(i, 1)\n        }\n      }\n      bindQuill (quill) {\n        var self = this\n\n        // this function makes sure that either the\n        // quill event is executed, or the yjs observer is executed\n        var token = true\n        function mutualExcluse (f) {\n          if (token) {\n            token = false\n            try {\n              f()\n            } catch (e) {\n              token = true\n              throw new Error(e)\n            }\n            token = true\n          }\n        }\n\n        quill.setContents(this.toDelta())\n\n        function quillCallback (delta) {\n          mutualExcluse(function () {\n            self.applyDelta(delta, quill)\n          })\n        }\n        quill.on('text-change', quillCallback)\n\n        function yCallback (event) {\n          mutualExcluse(function () {\n            var v // helper variable\n            var curSel // helper variable (current selection)\n            if (event.type === 'insert') {\n              var _value_i = 0\n              while (_value_i < event.values.length) {\n                var vals = []\n                while (_value_i < event.values.length && typeof event.values[_value_i] === 'string') {\n                  vals.push(event.values[_value_i])\n                  _value_i++\n                }\n                if (vals.length > 0) {\n                  var position = 0\n                  var insertSel = {}\n                  for (var l = event.index - 1; l >= 0; l--) {\n                    v = self._content[l].val\n                    if (typeof v === 'string') {\n                      position++\n                    } else if (v.constructor === Array && typeof insertSel[v[0]] === 'undefined') {\n                      insertSel[v[0]] = v[1]\n                    }\n                  }\n                  quill.insertText(position, vals.join(''), insertSel)\n                } else { // Array, that denotes a selection\n                  // a new selection is created\n                  // find left selection that matches newSel[0]\n                  curSel = null\n                  var newSel = event.values[_value_i++] // get selection, increment counter\n                  // denotes the start position of the selection\n                  // (without the selection objects)\n                  var selectionStart = 0\n                  for (var j = event.index + _value_i - 2/* -1 for index, -1 for incremented _value_i*/; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor === Array) {\n                      // check if v matches newSel\n                      if (newSel[0] === v[0]) {\n                        // found a selection\n                        // update curSel and go to next step\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // make sure to decrement j, so we correctly compute selectionStart\n                  for (; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (typeof v === 'string') {\n                      selectionStart++\n                    }\n                  }\n                  // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                  if (newSel[1] === curSel) {\n                    // both are the same. not necessary to do anything\n                    continue\n                  }\n                  // now find out the range over which newSel has to be created\n                  var selectionEnd = selectionStart\n                  for (var k = event.index + _value_i/* -1 for incremented _value_i, +1 for algorithm */; k < self._content.length; k++) {\n                    v = self._content[k].val\n                    if (v.constructor === Array) {\n                      if (v[0] === newSel[0]) {\n                        // found another selection with same attr name\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      selectionEnd++\n                    }\n                  }\n                  // create a selection from selectionStart to selectionEnd\n                  if (selectionStart !== selectionEnd) {\n                    quill.formatText(selectionStart, selectionEnd, newSel[0], newSel[1])\n                  }\n                }\n              }\n            } else if (event.type === 'delete') {\n              // sanitize events\n              var myEvents = []\n              for (var i = 0, _i = 0; i < event.length; i++) {\n                if (typeof event.values[i] !== 'string') {\n                  if (i !== _i) {\n                    myEvents.push({\n                      type: 'text',\n                      length: i - _i,\n                      index: event.index\n                    })\n                  }\n                  _i = i + 1\n                  myEvents.push({\n                    type: 'selection',\n                    val: event.values[i],\n                    index: event.index\n                  })\n                }\n              }\n              if (i !== _i) {\n                myEvents.push({\n                  type: 'text',\n                  length: i - _i,\n                  index: event.index\n                })\n              }\n              // ending sanitizing.. start brainfuck\n              myEvents.forEach(event => {\n                if (event.type === 'text') {\n                  var pos = 0\n                  for (var u = 0; u < event.index; u++) {\n                    v = self._content[u].val\n                    if (typeof v === 'string') {\n                      pos++\n                    }\n                  }\n                  quill.deleteText(pos, pos + event.length)\n                } else {\n                  curSel = null\n                  var from = 0\n                  var x\n                  for (x = event.index - 1; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) {\n                        curSel = v[1]\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  for (; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (typeof v === 'string') {\n                      from++\n                    }\n                  }\n                  var to = from\n                  for (x = event.index; x < self._content.length; x++) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) {\n                        break\n                      }\n                    } else if (typeof v === 'string') {\n                      to++\n                    }\n                  }\n                  if (curSel !== event.val[1] && from !== to) {\n                    quill.formatText(from, to, event.val[0], curSel)\n                  }\n                }\n              })\n            }\n            quill.editor.checkUpdate()\n          })\n        }\n        this.observe(yCallback)\n        this.instances.push({\n          editor: quill,\n          yCallback: yCallback,\n          quillCallback: quillCallback\n        })\n      }\n      * _changed () {\n        this.instances.forEach(function (instance) {\n          instance.editor.editor.checkUpdate()\n        })\n        yield* Y.Array.typeDefinition['class'].prototype._changed.apply(this, arguments)\n      }\n    }\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: function * YTextInitializer (os, model) {\n        var _content = []\n        yield* Y.Struct.List.map.call(this, model, function (op) {\n          if (op.hasOwnProperty('opContent')) {\n            throw new Error('Text must not contain types!')\n          } else {\n            op.content.forEach(function (c, i) {\n              _content.push({\n                id: [op.id[0], op.id[1] + i],\n                val: op.content[i]\n              })\n            })\n          }\n        })\n        return new YRichtext(os, model.id, _content)\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/* global Y */\n'use strict';\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction extend(Y) {\n  Y.requestModules(['Array']).then(function () {\n    var YRichtext = (function (_Y$Array$typeDefiniti) {\n      _inherits(YRichtext, _Y$Array$typeDefiniti);\n\n      function YRichtext(os, _model, _content) {\n        _classCallCheck(this, YRichtext);\n\n        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(YRichtext).call(this, os, _model, _content));\n\n        _this.instances = [];\n        return _this;\n      }\n\n      _createClass(YRichtext, [{\n        key: '_destroy',\n        value: function _destroy() {\n          for (var i = this.instances.length - 1; i >= 0; i--) {\n            this.unbindQuill(this.instances[i].editor);\n          }\n          _get(Object.getPrototypeOf(YRichtext.prototype), '_destroy', this).call(this);\n        }\n      }, {\n        key: 'toString',\n        value: function toString() {\n          return this._content.map(function (v) {\n            if (typeof v.val === 'string') {\n              return v.val;\n            }\n          }).join('');\n        }\n      }, {\n        key: 'toDelta',\n        value: function toDelta() {\n          var ops = [];\n          var op = {\n            insert: [],\n            attributes: {}\n          };\n          function createNewOp() {\n            var attrs = {};\n            // copy attributes\n            for (var name in op.attributes) {\n              attrs[name] = op.attributes[name];\n            }\n            op = {\n              insert: [],\n              attributes: attrs\n            };\n          }\n          var i = 0;\n          for (; i < this._content.length; i++) {\n            var v = this._content[i].val;\n            if (v.constructor === Array) {\n              if (op.insert.length > 0) {\n                op.insert = op.insert.join('');\n                ops.push(op);\n                createNewOp();\n              }\n              if (v[1] === null) {\n                delete op.attributes[v[0]];\n              } else {\n                op.attributes[v[0]] = v[1];\n              }\n            } else {\n              op.insert.push(v);\n            }\n          }\n          if (op.insert.length > 0) {\n            op.insert = op.insert.join('');\n            ops.push(op);\n          }\n          return ops;\n        }\n      }, {\n        key: 'insert',\n        value: function insert(pos, content) {\n          var curPos = 0;\n          var selection = {};\n          for (var i = 0; i < this._content.length; i++) {\n            if (curPos === pos) {\n              break;\n            }\n            var v = this._content[i].val;\n            if (typeof v === 'string') {\n              curPos++;\n            } else if (v.constructor === Array) {\n              if (v[1] === null) {\n                delete selection[v[0]];\n              } else {\n                selection[v[0]] = v[1];\n              }\n            }\n          }\n          _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, i, content.split(''));\n          return selection;\n        }\n      }, {\n        key: 'delete',\n        value: function _delete(pos, length) {\n          /*\n            let x = to be deleted string\n            let s = some string\n            let * = some selection\n            E.g.\n            sss*s***x*xxxxx***xx*x**ss*s\n                 |---delete-range--|\n               delStart         delEnd\n             We'll check the following\n            * is it possible to delete some of the selections?\n              1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n              2. a selections could be overwritten by another selection to the right\n          */\n          var curPos = 0;\n          var curSel = {};\n          var endPos = pos + length;\n          if (length <= 0) return;\n          var delStart; // relative to _content\n          var delEnd; // ..\n          var v, i; // helper variable for elements of _content\n\n          for (delStart = 0; curPos < pos && delStart < this._content.length; delStart++) {\n            v = this._content[delStart].val;\n            if (typeof v === 'string') {\n              curPos++;\n            } else if (v.constructor === Array) {\n              curSel[v[0]] = v[1];\n            }\n          }\n          for (delEnd = delStart; curPos < endPos && delEnd < this._content.length; delEnd++) {\n            v = this._content[delEnd].val;\n            if (typeof v === 'string') {\n              curPos++;\n            }\n          }\n          if (delEnd === this._content.length) {\n            // yay, you can delete everything without checking\n            _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, delStart, delEnd - delStart);\n          } else {\n            if (typeof v === 'string') {\n              delEnd--;\n            }\n            var rightSel = {};\n            for (i = delEnd; i >= delStart; i--) {\n              v = this._content[i].val;\n              if (v.constructor === Array) {\n                if (rightSel[v[0]] === undefined) {\n                  if (v[1] === curSel[v[0]]) {\n                    // case 1.\n                    _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n                  }\n                  rightSel[v[0]] = v[1];\n                } else {\n                  // case 2.\n                  _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, 1);\n                }\n              } else if (typeof v === 'string') {\n                var end = i + 1;\n                while (i > delStart) {\n                  v = this._content[i - 1].val;\n                  if (typeof v === 'string') {\n                    i--;\n                  } else {\n                    break;\n                  }\n                }\n                // always delete the strings\n                _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, i, end - i);\n              }\n            }\n          }\n        }\n        /*\n        1. get selection attributes from position $from\n           (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n        2. Insert selection $attr, if necessary\n        3. Between from and to, we'll delete all selections that do not match $attr.\n           Furthermore, we'll update antiAttrs, if necessary\n        4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs\n        */\n\n      }, {\n        key: 'select',\n        value: function select(from, to, attrName, attrValue) {\n          if (from == null || to == null || attrName == null || attrValue === undefined) {\n            throw new Error('You must define four parameters');\n          } else {\n            var step2i;\n            var step2sel;\n            var antiAttrs = [attrName, null];\n            var curPos = 0;\n            var i = 0;\n            // 1. compute antiAttrs\n            for (; i < this._content.length; i++) {\n              var _v = this._content[i].val;\n              if (curPos === from) {\n                break;\n              }\n              if (_v.constructor === Array) {\n                if (_v[0] === attrName) {\n                  antiAttrs[1] = _v[1];\n                }\n              } else if (typeof _v === 'string') {\n                curPos++;\n              }\n            }\n            // 2. Insert attr\n            if (antiAttrs[1] !== attrValue) {\n              // we'll execute this later\n              step2i = i;\n              step2sel = [attrName, attrValue];\n            }\n\n            // 3. update antiAttrs, modify selection\n            var deletes = [];\n            for (; i < this._content.length; i++) {\n              var _v2 = this._content[i].val;\n              if (curPos === to) {\n                break;\n              }\n              if (_v2.constructor === Array) {\n                if (_v2[0] === attrName) {\n                  antiAttrs[1] = _v2[1];\n                  deletes.push(i);\n                }\n              } else if (typeof _v2 === 'string') {\n                curPos++;\n              }\n            }\n            // actually delete the found selections\n            // also.. we have to delete from right to left (so that the positions dont change)\n            for (var j = deletes.length - 1; j >= 0; j--) {\n              var del = deletes[j];\n              _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, del, 1);\n              // update i, rel. to\n              if (del < i) {\n                i--;\n              }\n              if (del < step2i) {\n                step2i--;\n              }\n            }\n            // 4. Update selection to match antiAttrs\n            // never insert, if not necessary\n            //  1. when it is the last position ~ i < _content.length)\n            //  2. when a similar attrName already exists between i and the next character\n            if (antiAttrs[1] !== attrValue && i < this._content.length) {\n              // check 1.\n              var performStep4 = true;\n              var v;\n              for (j = i; j < this._content.length; j++) {\n                v = this._content[j].val;\n                if (v.constructor !== Array) {\n                  break;\n                }\n                if (v[0] === attrName) {\n                  performStep4 = false; // check 2.\n                  if (v[1] === attrValue) {\n                    _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, j, 1);\n                  }\n                  break;\n                }\n              }\n              if (performStep4) {\n                var sel = [attrName, antiAttrs[1]];\n                _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, i, [sel]);\n              }\n            }\n            if (step2i != null) {\n              _get(Object.getPrototypeOf(YRichtext.prototype), 'insert', this).call(this, step2i, [step2sel]);\n              // if there are some selections to the left of step2sel, delete them if possible\n              // * have same attribute name\n              // * no insert between step2sel and selection\n              for (j = step2i - 1; j >= 0; j--) {\n                v = this._content[j].val;\n                if (v.constructor !== Array) {\n                  break;\n                }\n                if (v[0] === attrName) {\n                  _get(Object.getPrototypeOf(YRichtext.prototype), 'delete', this).call(this, j, 1);\n                }\n              }\n            }\n          }\n        }\n        /*\n          This method accepts a quill delta (http://quilljs.com/docs/deltas/)\n          The second parameter (_quill) is optional (it is only necessary when binding a quill instance)\n        */\n\n      }, {\n        key: 'applyDelta',\n        value: function applyDelta(delta, _quill) {\n          var pos = 0;\n          var name; // helper variable\n          for (var i = 0; i < delta.ops.length; i++) {\n            var op = delta.ops[i];\n            if (op.insert != null) {\n              var attrs = this.insert(pos, op.insert);\n              // create new selection\n              for (name in op.attributes) {\n                if (op.attributes[name] !== attrs[name]) {\n                  this.select(pos, pos + op.insert.length, name, op.attributes[name]);\n                }\n              }\n              // not-existence of an attribute in op.attributes denotes\n              // that we have to unselect (set to null)\n              for (name in attrs) {\n                if (op.attributes == null || attrs[name] !== op.attributes[name]) {\n                  this.select(pos, pos + op.insert.length, name, null);\n                }\n              }\n              pos += op.insert.length;\n            }\n            if (op.delete != null) {\n              this.delete(pos, op.delete);\n            }\n            if (op.retain != null && _quill != null) {\n              var afterRetain = pos + op.retain;\n              if (afterRetain > this.length) {\n                var additionalContent = _quill.getText(this.length);\n                _quill.insertText(this.length, additionalContent);\n                // quill.deleteText(this.length + additionalContent.length, quill.getLength())\n                for (name in op.attributes) {\n                  _quill.formatText(this.length + additionalContent.length, this.length + additionalContent.length * 2, name, null);\n                  // quill.deleteText(this.length, this.length + op.retain)\n                }\n                this.insert(this.length, additionalContent);\n                // op.attributes = null\n              }\n              for (name in op.attributes) {\n                this.select(pos, pos + op.retain, name, op.attributes[name]);\n                _quill.formatText(pos, pos + op.retain, name, op.attributes[name]);\n              }\n              pos = afterRetain;\n            }\n          }\n        }\n      }, {\n        key: 'bind',\n        value: function bind() {\n          this.bindQuill.apply(this, arguments);\n        }\n      }, {\n        key: 'unbindQuill',\n        value: function unbindQuill(quill) {\n          var i = this.instances.findIndex(function (binding) {\n            return binding.editor === quill;\n          });\n          if (i >= 0) {\n            var binding = this.instances[i];\n            this.unobserve(binding.yCallback);\n            binding.editor.off('text-change', binding.quillCallback);\n            this.instances.splice(i, 1);\n          }\n        }\n      }, {\n        key: 'bindQuill',\n        value: function bindQuill(quill) {\n          var self = this;\n\n          // this function makes sure that either the\n          // quill event is executed, or the yjs observer is executed\n          var token = true;\n          function mutualExcluse(f) {\n            if (token) {\n              token = false;\n              try {\n                f();\n              } catch (e) {\n                token = true;\n                throw new Error(e);\n              }\n              token = true;\n            }\n          }\n\n          quill.setContents(this.toDelta());\n\n          function quillCallback(delta) {\n            mutualExcluse(function () {\n              self.applyDelta(delta, quill);\n            });\n          }\n          quill.on('text-change', quillCallback);\n\n          function yCallback(event) {\n            mutualExcluse(function () {\n              var v; // helper variable\n              var curSel; // helper variable (current selection)\n              if (event.type === 'insert') {\n                var _value_i = 0;\n                while (_value_i < event.values.length) {\n                  var vals = [];\n                  while (_value_i < event.values.length && typeof event.values[_value_i] === 'string') {\n                    vals.push(event.values[_value_i]);\n                    _value_i++;\n                  }\n                  if (vals.length > 0) {\n                    var position = 0;\n                    var insertSel = {};\n                    for (var l = event.index - 1; l >= 0; l--) {\n                      v = self._content[l].val;\n                      if (typeof v === 'string') {\n                        position++;\n                      } else if (v.constructor === Array && typeof insertSel[v[0]] === 'undefined') {\n                        insertSel[v[0]] = v[1];\n                      }\n                    }\n                    quill.insertText(position, vals.join(''), insertSel);\n                  } else {\n                    // Array, that denotes a selection\n                    // a new selection is created\n                    // find left selection that matches newSel[0]\n                    curSel = null;\n                    var newSel = event.values[_value_i++]; // get selection, increment counter\n                    // denotes the start position of the selection\n                    // (without the selection objects)\n                    var selectionStart = 0;\n                    for (var j = event.index + _value_i - 2 /* -1 for index, -1 for incremented _value_i*/; j >= 0; j--) {\n                      v = self._content[j].val;\n                      if (v.constructor === Array) {\n                        // check if v matches newSel\n                        if (newSel[0] === v[0]) {\n                          // found a selection\n                          // update curSel and go to next step\n                          curSel = v[1];\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        selectionStart++;\n                      }\n                    }\n                    // make sure to decrement j, so we correctly compute selectionStart\n                    for (; j >= 0; j--) {\n                      v = self._content[j].val;\n                      if (typeof v === 'string') {\n                        selectionStart++;\n                      }\n                    }\n                    // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                    if (newSel[1] === curSel) {\n                      // both are the same. not necessary to do anything\n                      continue;\n                    }\n                    // now find out the range over which newSel has to be created\n                    var selectionEnd = selectionStart;\n                    for (var k = event.index + _value_i /* -1 for incremented _value_i, +1 for algorithm */; k < self._content.length; k++) {\n                      v = self._content[k].val;\n                      if (v.constructor === Array) {\n                        if (v[0] === newSel[0]) {\n                          // found another selection with same attr name\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        selectionEnd++;\n                      }\n                    }\n                    // create a selection from selectionStart to selectionEnd\n                    if (selectionStart !== selectionEnd) {\n                      quill.formatText(selectionStart, selectionEnd, newSel[0], newSel[1]);\n                    }\n                  }\n                }\n              } else if (event.type === 'delete') {\n                // sanitize events\n                var myEvents = [];\n                for (var i = 0, _i = 0; i < event.length; i++) {\n                  if (typeof event.values[i] !== 'string') {\n                    if (i !== _i) {\n                      myEvents.push({\n                        type: 'text',\n                        length: i - _i,\n                        index: event.index\n                      });\n                    }\n                    _i = i + 1;\n                    myEvents.push({\n                      type: 'selection',\n                      val: event.values[i],\n                      index: event.index\n                    });\n                  }\n                }\n                if (i !== _i) {\n                  myEvents.push({\n                    type: 'text',\n                    length: i - _i,\n                    index: event.index\n                  });\n                }\n                // ending sanitizing.. start brainfuck\n                myEvents.forEach(function (event) {\n                  if (event.type === 'text') {\n                    var pos = 0;\n                    for (var u = 0; u < event.index; u++) {\n                      v = self._content[u].val;\n                      if (typeof v === 'string') {\n                        pos++;\n                      }\n                    }\n                    quill.deleteText(pos, pos + event.length);\n                  } else {\n                    curSel = null;\n                    var from = 0;\n                    var x;\n                    for (x = event.index - 1; x >= 0; x--) {\n                      v = self._content[x].val;\n                      if (v.constructor === Array) {\n                        if (v[0] === event.val[0]) {\n                          curSel = v[1];\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        from++;\n                      }\n                    }\n                    for (; x >= 0; x--) {\n                      v = self._content[x].val;\n                      if (typeof v === 'string') {\n                        from++;\n                      }\n                    }\n                    var to = from;\n                    for (x = event.index; x < self._content.length; x++) {\n                      v = self._content[x].val;\n                      if (v.constructor === Array) {\n                        if (v[0] === event.val[0]) {\n                          break;\n                        }\n                      } else if (typeof v === 'string') {\n                        to++;\n                      }\n                    }\n                    if (curSel !== event.val[1] && from !== to) {\n                      quill.formatText(from, to, event.val[0], curSel);\n                    }\n                  }\n                });\n              }\n              quill.editor.checkUpdate();\n            });\n          }\n          this.observe(yCallback);\n          this.instances.push({\n            editor: quill,\n            yCallback: yCallback,\n            quillCallback: quillCallback\n          });\n        }\n      }, {\n        key: '_changed',\n        value: regeneratorRuntime.mark(function _changed() {\n          var _args = arguments;\n          return regeneratorRuntime.wrap(function _changed$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this.instances.forEach(function (instance) {\n                    instance.editor.editor.checkUpdate();\n                  });\n                  return _context.delegateYield(Y.Array.typeDefinition['class'].prototype._changed.apply(this, _args), 't0', 2);\n\n                case 2:\n                case 'end':\n                  return _context.stop();\n              }\n            }\n          }, _changed, this);\n        })\n      }, {\n        key: 'length',\n        get: function get() {\n          /*\n            TODO: I must not use observe to compute the length.\n            But since I inherit from Y.Array, I can't set observe\n            the changes at the right momet (for that I would require direct access to EventHandler).\n            This is the most elegant solution, for now.\n            But at some time you should re-write Y.Richtext more elegantly!!\n          */\n          return this.toString().length;\n        }\n      }]);\n\n      return YRichtext;\n    })(Y.Array.typeDefinition['class']);\n\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: regeneratorRuntime.mark(function YTextInitializer(os, model) {\n        var _content;\n\n        return regeneratorRuntime.wrap(function YTextInitializer$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _content = [];\n                return _context2.delegateYield(Y.Struct.List.map.call(this, model, function (op) {\n                  if (op.hasOwnProperty('opContent')) {\n                    throw new Error('Text must not contain types!');\n                  } else {\n                    op.content.forEach(function (c, i) {\n                      _content.push({\n                        id: [op.id[0], op.id[1] + i],\n                        val: op.content[i]\n                      });\n                    });\n                  }\n                }), 't0', 2);\n\n              case 2:\n                return _context2.abrupt('return', new YRichtext(os, model.id, _content));\n\n              case 3:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, YTextInitializer, this);\n      })\n    }));\n  });\n}\n\nmodule.exports = extend;\nif (typeof Y !== 'undefined') {\n  extend(Y);\n}\n\n},{}]},{},[1])\n\n"],"sourceRoot":"/source/"}