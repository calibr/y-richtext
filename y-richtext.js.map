{"version":3,"sources":["../yjs/node_modules/browser-pack/_prelude.js","src/Richtext.js","y-richtext.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","extend","Y","requestModules","then","YRichtext","_Y$Array$typeDefiniti","os","_model","_content","this","_this","getPrototypeOf","instances","eventHandler","_pullChanges","forEach","editor","update","_createClass","key","unbindQuill","_get","map","v","val","join","createNewOp","attrs","name","op","attributes","insert","newLineCharacter","c","Array","push","ops","hasOwnProperty","keys","pos","content","curPos","selection","ins","split","curSel","endPos","delStart","delEnd","rightSel","undefined","end","from","to","attrName","attrValue","step2i","step2sel","antiAttrs","_v","deletes","_v2","j","del","performStep4","sel","delta","_quill","insLength","select","retain","afterRetain","additionalContent","getText","insertText","formatText","attr","bindQuill","apply","arguments","quill","findIndex","binding","unobserve","yCallback","off","quillCallback","splice","mutualExcluse","token","applyDelta","event","type","_value_i","values","vals","position","insertSel","index","unshift","typeDefinition","currText","updateContents","newSel","selectionStart","selectionEnd","k","myEvents","_i","deleteText","x","setContents","toDelta","on","observe","get","toString","utils","CustomType","class","struct","initType","regeneratorRuntime","mark","YTextInitializer","model","wrap","_context","prev","next","delegateYield","Struct","List","id","abrupt","stop","defineProperties","target","props","descriptor","defineProperty","protoProps","staticProps","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getter"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,GCCA,YCOA,SAASK,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,GAA2BC,EAAMT,GAAQ,IAAKS,EAAQ,KAAM,IAAIC,gBAAe,4DAAgE,QAAOV,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BS,EAAPT,EAElO,QAASW,GAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIN,WAAU,iEAAoEM,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GDTje,QAASW,GAAQC,GACfA,EAAEC,gBAAgB,UAAUC,KAAK,WAAY,GACrCC,GADqC,SAAAC,GAEzC,QAAAD,GAAaE,EAAIC,EAAQC,GAAU5B,EAAA6B,KAAAL,EAAA,IAAAM,GAAA1B,EAAAyB,KAAAlB,OAAAoB,eAAAP,GAAA5B,KAAAiC,KAC3BH,EAAIC,EAAQC,GADe,OAEjCE,GAAKE,aAELF,EAAKG,aAAaC,aAAe,WAC/BJ,EAAKE,UAAUG,QAAQ,SAAUlC,GAC/BA,EAASmC,OAAOC,YANaP,EAFM,MAAAvB,GAAAiB,EAAAC,GAAAa,EAAAd,IAAAe,IAAA,WAAAzB,MAAA,WAavC,IAAK,GAAIxB,GAAIuC,KAAKG,UAAUnC,OAAS,EAAGP,GAAK,EAAGA,IAC9CuC,KAAKW,YAAYX,KAAKG,UAAU1C,GAAG8C,OAErCK,GAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,WAAAmB,MAAAjC,KAAAiC,SAhBuCU,IAAA,WAAAzB,MAAA,WA6BvC,MAAOe,MAAKD,SAASc,IAAI,SAAUC,GACjC,MAAqB,gBAAVA,GAAEC,IACJD,EAAEC,IADX,SAGCC,KAAK,OAjC+BN,IAAA,UAAAzB,MAAA,WA2DvC,QAASgC,KACP,GAAIC,KAEJ,KAAK,GAAIC,KAAQC,GAAGC,WAClBH,EAAMC,GAAQC,EAAGC,WAAWF,EAE9BC,IACEE,UACAD,WAAYH,GA3BhB,IAAK,GADDK,IAAmB,EACd9D,EAAIuC,KAAKD,SAAS/B,OAAS,EAAGP,GAAK,EAAGA,IAAK,CAClD,GAAI+D,GAAIxB,KAAKD,SAAStC,EACtB,IAAI+D,EAAET,IAAI/B,cAAgByC,MAAO,CACjB,OAAVD,EAAET,MACJQ,GAAmB,EAErB,QAGCA,GACHvB,KAAK0B,KAAK,KAIZ,IAAIC,MACAP,GACFE,UACAD,cAcF,KADA5D,EAAI,EACGA,EAAIuC,KAAKD,SAAS/B,OAAQP,IAAK,CACpC,GAAIqD,GAAId,KAAKD,SAAStC,GAAGsD,GACzB,IAAID,EAAE9B,cAAgByC,MAAO,CAC3B,IAAML,EAAGC,WAAWO,eAAed,EAAE,KAAe,MAARA,EAAE,IAAeM,EAAGC,WAAWP,EAAE,MAAQA,EAAE,GACrF,QAEEM,GAAGE,OAAOtD,OAAS,IACrBoD,EAAGE,OAASF,EAAGE,OAAON,KAAK,IAC3BW,EAAID,KAAKN,GACTH,KAEW,OAATH,EAAE,SACGM,GAAGC,WAAWP,EAAE,IAEvBM,EAAGC,WAAWP,EAAE,IAAMA,EAAE,OAEJ,gBAANA,GAChBM,EAAGE,OAAOI,KAAKZ,IAEXM,EAAGE,OAAOtD,OAAS,IACrBoD,EAAGE,OAASF,EAAGE,OAAON,KAAK,IAC3BW,EAAID,KAAKN,GACTH,KAEFG,EAAGE,OAASR,EACZa,EAAID,KAAKN,GACTH,KAYJ,MATIG,GAAGE,OAAOtD,OAAS,IACrBoD,EAAGE,OAASF,EAAGE,OAAON,KAAK,IAC3BW,EAAID,KAAKN,IAEXO,EAAId,IAAI,SAAUO,GAC0B,IAAtCtC,OAAO+C,KAAKT,EAAGC,YAAYrD,cACtBoD,GAAGC,aAGPM,KA7GgCjB,IAAA,SAAAzB,MAAA,SA+GjC6C,EAAKC,GAGX,IAAK,GAFDC,GAAS,EACTC,KACKxE,EAAI,EAAGA,EAAIuC,KAAKD,SAAS/B,QAC5BgE,IAAWF,EADyBrE,IAAK,CAI7C,GAAIqD,GAAId,KAAKD,SAAStC,GAAGsD,GACrBD,GAAE9B,cAAgByC,MACpBO,IAEa,OAATlB,EAAE,SACGmB,GAAUnB,EAAE,IAEnBmB,EAAUnB,EAAE,IAAMA,EAAE,GAI1B,GAAIoB,EASJ,OAPEA,GADqB,gBAAZH,GACHA,EAAQI,MAAM,IACXJ,EAAQ/C,cAAgBF,QAC1BiD,GAEDA,EAERnB,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAavC,EAAGyE,GACTD,KA1IgCvB,IAAA,SAAAzB,MAAA,SA4IjC6C,EAAK9D,GAeX,GAAIgE,GAAS,EACTI,KACAC,EAASP,EAAM9D,CACnB,MAAc,GAAVA,GAAJ,CACA,GAAIsE,GACAC,EACAzB,EAAGrD,CAEP,KAAK6E,EAAW,EAAYR,EAATE,GAAgBM,EAAWtC,KAAKD,SAAS/B,OAAQsE,IAClExB,EAAId,KAAKD,SAASuC,GAAUvB,IACxBD,EAAE9B,cAAgByC,MACpBO,IAEAI,EAAOtB,EAAE,IAAMA,EAAE,EAGrB,KAAKyB,EAASD,EAAmBD,EAATL,GAAmBO,EAASvC,KAAKD,SAAS/B,OAAQuE,IACxEzB,EAAId,KAAKD,SAASwC,GAAQxB,IACtBD,EAAE9B,cAAgByC,OACpBO,GAGJ,IAAIO,IAAWvC,KAAKD,SAAS/B,OAE3B4C,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAasC,EAAUC,EAASD,OAC3B,CACDxB,EAAE9B,cAAgByC,OACpBc,GAEF,IAAIC,KACJ,KAAK/E,EAAI8E,EAAQ9E,GAAK6E,EAAU7E,IAE9B,GADAqD,EAAId,KAAKD,SAAStC,GAAGsD,IACjBD,EAAE9B,cAAgByC,MACGgB,SAAnBD,EAAS1B,EAAE,KACTA,EAAE,KAAOsB,EAAOtB,EAAE,KAEpBF,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAavC,EAAG,GAElB+E,EAAS1B,EAAE,IAAMA,EAAE,IAGnBF,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAavC,EAAG,OAEb,CAEL,IADA,GAAIiF,GAAMjF,EAAI,EACPA,EAAI6E,IACTxB,EAAId,KAAKD,SAAStC,EAAI,GAAGsD,IACrBD,EAAE9B,cAAgByC,QACpBhE,GAMJmD,GAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAavC,EAAGiF,EAAMjF,SAjNWiD,IAAA,SAAAzB,MAAA,SA8NjC0D,EAAMC,EAAIC,EAAUC,GAC1B,GAAY,MAARH,GAAsB,MAANC,GAA0B,MAAZC,GAAkCJ,SAAdK,EACpD,KAAM,IAAInF,OAAM,kCAQhB,KANA,GAAIoF,GACAC,EACAC,GAAaJ,EAAU,MACvBb,EAAS,EACTvE,EAAI,EAEDA,EAAIuC,KAAKD,SAAS/B,OAAQP,IAAK,CACpC,GAAIyF,GAAIlD,KAAKD,SAAStC,GAAGsD,GACzB,IAAIiB,IAAWW,EACb,KAEEO,GAAElE,cAAgByC,MAEhByB,EAAE,KAAOL,IACXI,EAAU,GAAKC,EAAE,IAInBlB,IAIAiB,EAAU,KAAOH,IAEnBC,EAAStF,EACTuF,GAAYH,EAAUC,GAKxB,KADA,GAAIK,MACG1F,EAAIuC,KAAKD,SAAS/B,OAAQP,IAAK,CACpC,GAAI2F,GAAIpD,KAAKD,SAAStC,GAAGsD,GACzB,IAAIiB,IAAWY,EACb,KAEEQ,GAAEpE,cAAgByC,MAEhB2B,EAAE,KAAOP,IACXI,EAAU,GAAKG,EAAE,GACjBD,EAAQzB,KAAKjE,IAIfuE,IAKJ,IAAK,GAAIqB,GAAIF,EAAQnF,OAAS,EAAGqF,GAAK,EAAGA,IAAK,CAC5C,GAAIC,GAAMH,EAAQE,EAClBzC,GAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAasD,EAAK,GAER7F,EAAN6F,GACF7F,IAEQsF,EAANO,GACFP,IAOJ,GAAIE,EAAU,KAAOH,GAAarF,EAAIuC,KAAKD,SAAS/B,OAAQ,CAC1D,GACI8C,GADAyC,GAAe,CAEnB,KAAKF,EAAI5F,EAAG4F,EAAIrD,KAAKD,SAAS/B,SAC5B8C,EAAId,KAAKD,SAASsD,GAAGtC,IACjBD,EAAE9B,cAAgByC,OAFc4B,IAKpC,GAAIvC,EAAE,KAAO+B,EAAU,CACrBU,GAAe,EACXzC,EAAE,KAAOgC,GACXlC,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAaqD,EAAG,EAElB,OAGJ,GAAIE,EAAc,CAChB,GAAIC,IAAOX,EAAUI,EAAU,GAC/BrC,GAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAavC,GAAI+F,KAGrB,GAAc,MAAVT,EAKF,IAJAnC,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAa+C,GAASC,IAIjBK,EAAIN,EAAS,EAAGM,GAAK,IACxBvC,EAAId,KAAKD,SAASsD,GAAGtC,IACjBD,EAAE9B,cAAgByC,OAFK4B,IAKvBvC,EAAE,KAAO+B,GACXjC,EAAA9B,OAAAoB,eAAAP,EAAAd,WAAA,SAAAmB,MAAAjC,KAAAiC,KAAaqD,EAAG,MAjUe3C,IAAA,aAAAzB,MAAA,SA2U7BwE,EAAOC,GAGjB,IAAK,GADDvC,GADAW,EAAM,EAEDrE,EAAI,EAAGA,EAAIgG,EAAM9B,IAAI3D,OAAQP,IAAK,CACzC,GACIyD,GACAyC,EAFAvC,EAAKqC,EAAM9B,IAAIlE,EAGnB,IAAiB,MAAb2D,EAAGE,OAAgB,CACI,gBAAdF,GAAGE,QACZJ,EAAQlB,KAAKsB,OAAOQ,EAAKV,EAAGE,QAC5BqC,EAAYvC,EAAGE,OAAOtD,SAEtBkD,EAAQlB,KAAKsB,OAAOQ,EAAKV,EAAGE,QAC5BqC,EAAY,EAGd,KAAKxC,IAAQC,GAAGC,WACVD,EAAGC,WAAWF,KAAUD,EAAMC,IAChCnB,KAAK4D,OAAO9B,EAAKA,EAAM6B,EAAWxC,EAAMC,EAAGC,WAAWF,GAK1D,KAAKA,IAAQD,IACU,MAAjBE,EAAGC,YAAsBH,EAAMC,KAAUC,EAAGC,WAAWF,KACzDnB,KAAK4D,OAAO9B,EAAKA,EAAM6B,EAAWxC,EAAM,KAG5CW,IAAO6B,EAKT,GAHiB,MAAbvC,EAAAA,WACFpB,KAAAA,UAAY8B,EAAKV,EAAAA,WAEF,MAAbA,EAAGyC,QAA4B,MAAVH,EAAgB,CACvC,GAAII,GAAchC,EAAMV,EAAGyC,MAC3B,IAAIC,EAAc9D,KAAKhC,OAAQ,CAE7B,GAAI+F,GAAoBL,EAAOM,QAAQhE,KAAKhC,OAC5C0F,GAAOO,WAAWjE,KAAKhC,OAAQ+F,EAE/B,KAAK5C,IAAQC,GAAGC,WAEdqC,EAAOQ,WAAWlE,KAAKhC,OAAS+F,EAAkB/F,OAAQ+F,EAAkB/F,OAAQmD,EAAM,KAG5FnB,MAAKsB,OAAOtB,KAAKhC,OAAQ+F,GAG3B,IAAK5C,IAAQC,GAAGC,WAAY,CAC1B,GAAI8C,GAAO/C,EAAGC,WAAWF,EACzBnB,MAAK4D,OAAO9B,EAAKA,EAAMV,EAAGyC,OAAQ1C,EAAMgD,GAExCT,EAAOQ,WAAWpC,EAAKV,EAAGyC,OAAQ1C,EAAc,MAARgD,GAAe,EAAQA,GAEjErC,EAAMgC,OAjY6BpD,IAAA,OAAAzB,MAAA,WAsYvCe,KAAKoE,UAAUC,MAAMrE,KAAMsE,cAtYY5D,IAAA,cAAAzB,MAAA,SAwY5BsF,GACX,GAAI9G,GAAIuC,KAAKG,UAAUqE,UAAU,SAAUC,GACzC,MAAOA,GAAQlE,SAAWgE,GAE5B,IAAI9G,GAAK,EAAG,CACV,GAAIgH,GAAUzE,KAAKG,UAAU1C,EAC7BuC,MAAK0E,UAAUD,EAAQE,WACvBF,EAAQlE,OAAOqE,IAAI,cAAeH,EAAQI,eAC1C7E,KAAKG,UAAU2E,OAAOrH,EAAG,OAhZYiD,IAAA,YAAAzB,MAAA,SAmZ9BsF,GAMT,QAASQ,GAAerH,GACtB,GAAIsH,EAAO,CACTA,GAAQ,CACR,KACEtH,IACA,MAAOV,GAEP,KADAgI,IAAQ,EACF,GAAIrH,OAAMX,GAElBgI,GAAQ,GAKZ,QAASH,GAAepB,GACtBsB,EAAc,WACZvG,EAAKyG,WAAWxB,EAAOc,KAK3B,QAASI,GAAWO,GAClBH,EAAc,WACZ,GAAIjE,GACAsB,CACJ,IAAmB,WAAf8C,EAAMC,KAER,IADA,GAAIC,GAAW,EACRA,EAAWF,EAAMG,OAAOrH,QAAQ,CAErC,IADA,GAAIsH,MACGF,EAAWF,EAAMG,OAAOrH,QAAUkH,EAAMG,OAAOD,GAAUpG,cAAgByC,OAC9E6D,EAAK5D,KAAKwD,EAAMG,OAAOD,IACvBA,GAEF,IAAIE,EAAKtH,OAAS,EAAG,CAGnB,IAAK,GAFDuH,GAAW,EACXC,KACK3H,EAAI,EAAGA,EAAIqH,EAAMO,MAAO5H,IAC/BiD,EAAItC,EAAKuB,SAASlC,GAAGkD,IACjBD,EAAE9B,cAAgByC,MACpB8D,IAEAC,EAAU1E,EAAE,IAAMA,EAAE,EAOxB,KADAjD,EAAIqH,EAAMO,MAAQP,EAAMlH,OACjBH,EAAIW,EAAKuB,SAAS/B,SACvB8C,EAAItC,EAAKuB,SAASlC,GAAGkD,IACjBD,EAAE9B,cAAgByC,QACf+D,EAAU5D,eAAed,EAAE,MAC9B0E,EAAU1E,EAAE,IAAM,MAKtBjD,GAIF,KAAK,GAAIsD,KAAQqE,GACQ,MAAnBA,EAAUrE,KACZqE,EAAUrE,IAAQ,EAGtB,IAAI3C,EAAKR,SAAWuH,EAAWD,EAAKtH,QAAoC,OAA1BsH,EAAKA,EAAKtH,OAAS,GAAa,CAE5E,GAAI0E,IAAO,MACPc,IAEJ,KAAKrC,IAAQqE,GACPA,EAAUrE,MAAU,IACtBuB,EAAIgD,SAASvE,GAAM,IACnBqC,EAAIrC,IAAQ,EAGhB3B,GAAEiC,MAAMkE,eAARnG,SAA6BX,UAAUyC,OAAOvD,KAAKS,EAAM+G,EAAWD,EAAKtH,OAAQ0E,GACjF6B,EAAMN,WAAWsB,EAAU,KAAM/B,GAGnC,GAAIC,KACA8B,GAAW,GACb9B,EAAM/B,MAAOmC,OAAQ0B,GAEvB,IAAIK,KACJN,GAAKhF,QAAQ,SAAUQ,GACJ,gBAANA,GACT8E,EAASlE,KAAKZ,IAEV8E,EAAS5H,OAAS,IACpByF,EAAM/B,MACJJ,OAAQsE,EAAS5E,KAAK,IACtBK,WAAYmE,IAEdI,MAEFnC,EAAM/B,MACJJ,OAAQR,EACRO,WAAYmE,OAIdI,EAAS5H,OAAS,GACpByF,EAAM/B,MACJJ,OAAQsE,EAAS5E,KAAK,IACtBK,WAAYmE,IAGhBjB,EAAMsB,eAAepC,OAEhB,CAGLrB,EAAS,IAKT,KAAK,GAJD0D,GAASZ,EAAMG,OAAOD,KAGtBW,EAAiB,EACZ1C,EAAI6B,EAAMO,MAAQL,EAAW,EAAiD/B,GAAK,EAAGA,IAE7F,GADAvC,EAAItC,EAAKuB,SAASsD,GAAGtC,IACjBD,EAAE9B,cAAgByC,OAEpB,GAAIqE,EAAO,KAAOhF,EAAE,GAAI,CAGtBsB,EAAStB,EAAE,EACX,YAGFiF,IAIJ,MAAO1C,GAAK,EAAGA,IACbvC,EAAItC,EAAKuB,SAASsD,GAAGtC,IACjBD,EAAE9B,cAAgByC,OACpBsE,GAIJ,IAAID,EAAO,KAAO1D,EAEhB,QAIF,KAAK,GADD4D,GAAeD,EACVE,EAAIf,EAAMO,MAAQL,EAA6Da,EAAIzH,EAAKuB,SAAS/B,OAAQiI,IAEhH,GADAnF,EAAItC,EAAKuB,SAASkG,GAAGlF,IACjBD,EAAE9B,cAAgByC,OACpB,GAAIX,EAAE,KAAOgF,EAAO,GAElB,UAGFE,IAIAD,KAAmBC,GAErBzB,EAAML,WAAW6B,EAAgBC,EAAeD,EAAgBD,EAAO,GAAiB,MAAbA,EAAO,IAAa,EAAQA,EAAO,SAI/G,IAAmB,WAAfZ,EAAMC,KAAmB,CAGlC,IAAK,GADDe,MACKzI,EAAI,EAAG0I,EAAK,EAAG1I,EAAIyH,EAAMlH,OAAQP,IACpCyH,EAAMG,OAAO5H,GAAGuB,cAAgByC,QAC9BhE,IAAM0I,GACRD,EAASxE,MACPyD,KAAM,OACNnH,OAAQP,EAAI0I,EACZV,MAAOP,EAAMO,QAGjBU,EAAK1I,EAAI,EACTyI,EAASxE,MACPyD,KAAM,YACNpE,IAAKmE,EAAMG,OAAO5H,GAClBgI,MAAOP,EAAMO,QAIfhI,KAAM0I,GACRD,EAASxE,MACPyD,KAAM,OACNnH,OAAQP,EAAI0I,EACZV,MAAOP,EAAMO,QAIjBS,EAAS5F,QAAQ,SAAA4E,GACf,GAAmB,SAAfA,EAAMC,KAAiB,CAEzB,IAAK,GADDrD,GAAM,EACDxE,EAAI,EAAGA,EAAI4H,EAAMO,MAAOnI,IAC/BwD,EAAItC,EAAKuB,SAASzC,GAAGyD,IACjBD,EAAE9B,cAAgByC,OACpBK,GAGJyC,GAAM6B,WAAWtE,EAAKoD,EAAMlH,YACvB,CACLoE,EAAS,IACT,IACIiE,GADA1D,EAAO,CAEX,KAAK0D,EAAInB,EAAMO,MAAQ,EAAGY,GAAK,EAAGA,IAEhC,GADAvF,EAAItC,EAAKuB,SAASsG,GAAGtF,IACjBD,EAAE9B,cAAgByC,OACpB,GAAIX,EAAE,KAAOoE,EAAMnE,IAAI,GAAI,CACzBqB,EAAStB,EAAE,EACX,YAGF6B,IAGJ,MAAO0D,GAAK,EAAGA,IACbvF,EAAItC,EAAKuB,SAASsG,GAAGtF,IACjBD,EAAE9B,cAAgByC,OACpBkB,GAGJ,IAAIC,GAAKD,CACT,KAAK0D,EAAInB,EAAMO,MAAOY,EAAI7H,EAAKuB,SAAS/B,OAAQqI,IAE9C,GADAvF,EAAItC,EAAKuB,SAASsG,GAAGtF,IACjBD,EAAE9B,cAAgByC,OACpB,GAAIX,EAAE,KAAOoE,EAAMnE,IAAI,GACrB,UAGF6B,IAGAR,KAAW8C,EAAMnE,IAAI,IAAM4B,IAASC,GAEtC2B,EAAML,WAAWvB,EAAMC,EAAKD,EAAMuC,EAAMnE,IAAI,GAAc,MAAVqB,GAAiB,EAAQA,MAKjFmC,EAAM/D,WAvPV,GAAIhC,GAAOwB,KAIPgF,GAAQ,CAaZT,GAAM+B,YAAYtG,KAAKuG,WAOvBhC,EAAMiC,GAAG,cAAe3B,GAkOxB7E,KAAKyG,QAAQ9B,GACb3E,KAAKG,UAAUuB,MACbnB,OAAQgE,EACRI,UAAWA,EACXE,cAAeA,OAlpBsBnE,IAAA,SAAAgG,IAAA,WA0BvC,MAAO1G,MAAK2G,WAAW3I,WA1BgB2B,GACnBH,EAAEiC,MAAMkE,eAAe,SAqpB/CnG,GAAED,OAAO,WAAY,GAAIC,GAAEoH,MAAMC,YAC/B1F,KAAM,WACN2F,QAAOnH,EACPoH,OAAQ,OACRC,SAAAC,mBAAAC,KAAU,QAAWC,GAAkBtH,EAAIuH,GAAjC,GAAArH,EAAA,OAAAkH,oBAAAI,KAAA,SAAAC,GAAA,OAAA,OAAAA,EAAAC,KAAAD,EAAAE,MAAA,IAAA,GAAA,MACJzH,MADIuH,EAAAG,cAEDjI,EAAEkI,OAAOC,KAAK9G,IAAI9C,KAAKiC,KAAMoH,EAAO,SAAUhG,GACnD,GAAIA,EAAGQ,eAAe,aACpB,KAAM,IAAIjE,OAAM,+BAEhByD,GAAGW,QAAQzB,QAAQ,SAAUkB,EAAG/D,GAC9BsC,EAAS2B,MACPkG,IAAKxG,EAAGwG,GAAG,GAAIxG,EAAGwG,GAAG,GAAKnK,GAC1BsD,IAAKK,EAAGW,QAAQtE,SAThB,KAAA,EAAA,KAAA,GAAA,MAAA6J,GAAAO,OAAA,SAcD,GAAIlI,GAAUE,EAAIuH,EAAMQ,GAAI7H,GAd3B,KAAA,GAAA,IAAA,MAAA,MAAAuH,GAAAQ,SAAWX,EAAXnH,aC1pBhB,GAAIS,GAAe,WAAc,QAASsH,GAAiBC,EAAQC,GAAS,IAAK,GAAIxK,GAAI,EAAGA,EAAIwK,EAAMjK,OAAQP,IAAK,CAAE,GAAIyK,GAAaD,EAAMxK,EAAIyK,GAAWhJ,WAAagJ,EAAWhJ,aAAc,EAAOgJ,EAAW9I,cAAe,EAAU,SAAW8I,KAAYA,EAAW/I,UAAW,GAAML,OAAOqJ,eAAeH,EAAQE,EAAWxH,IAAKwH,IAAiB,MAAO,UAAU7J,EAAa+J,EAAYC,GAAiJ,MAA9HD,IAAYL,EAAiB1J,EAAYQ,UAAWuJ,GAAiBC,GAAaN,EAAiB1J,EAAagK,GAAqBhK,MAE5hBuC,EAAO,QAAS8F,GAAI4B,EAAQC,EAAUC,GAA2B,OAAXF,IAAiBA,EAASG,SAAS5J,UAAW,IAAI6J,GAAO5J,OAAO6J,yBAAyBL,EAAQC,EAAW,IAAa9F,SAATiG,EAAoB,CAAE,GAAIE,GAAS9J,OAAOoB,eAAeoI,EAAS,OAAe,QAAXM,EAA0BnG,OAA2BiE,EAAIkC,EAAQL,EAAUC,GAAoB,GAAI,SAAWE,GAAQ,MAAOA,GAAKzJ,KAAgB,IAAI4J,GAASH,EAAKhC,GAAK,OAAejE,UAAXoG,EAA+BpG,OAAoBoG,EAAO9K,KAAKyK,GD4qB5dtK,GAAOJ,QAAUyB,EACA,mBAANC,IACTD,EAAOC,aCoEE","file":"y-richtext.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* global Y */\n'use strict'\n\nfunction extend (Y) {\n  Y.requestModules(['Array']).then(function () {\n    class YRichtext extends Y.Array.typeDefinition['class'] {\n      constructor (os, _model, _content) {\n        super(os, _model, _content)\n        this.instances = []\n        // append this utility function with which eventhandler can pull changes from quill\n        this.eventHandler._pullChanges = () => {\n          this.instances.forEach(function (instance) {\n            instance.editor.update()\n          })\n        }\n      }\n      _destroy () {\n        for (var i = this.instances.length - 1; i >= 0; i--) {\n          this.unbindQuill(this.instances[i].editor)\n        }\n        super._destroy()\n      }\n      get length () {\n        /*\n          TODO: I must not use observe to compute the length.\n          But since I inherit from Y.Array, I can't set observe\n          the changes at the right momet (for that I would require direct access to EventHandler).\n          This is the most elegant solution, for now.\n          But at some time you should re-write Y.Richtext more elegantly!!\n        */\n        return this.toString().length\n      }\n      toString () {\n        return this._content.map(function (v) {\n          if (typeof v.val === 'string') {\n            return v.val\n          }\n        }).join('')\n      }\n      toDelta () {\n        // check last character\n        // insert a newline as the last character, if neccessary\n        // (quill will do that automatically otherwise..)\n        var newLineCharacter = false\n        for (var i = this._content.length - 1; i >= 0; i--) {\n          var c = this._content[i]\n          if (c.val.constructor !== Array) {\n            if (c.val === '\\n') {\n              newLineCharacter = true\n            }\n            break\n          }\n        }\n        if (!newLineCharacter) {\n          this.push('\\n')\n        }\n\n        // create the delta\n        var ops = []\n        var op = {\n          insert: [],\n          attributes: {}\n        }\n        function createNewOp () {\n          var attrs = {}\n          // copy attributes\n          for (var name in op.attributes) {\n            attrs[name] = op.attributes[name]\n          }\n          op = {\n            insert: [],\n            attributes: attrs\n          }\n        }\n        i = 0\n        for (; i < this._content.length; i++) {\n          let v = this._content[i].val\n          if (v.constructor === Array) {\n            if ((!op.attributes.hasOwnProperty(v[0]) && v[1] == null) || op.attributes[v[0]] === v[1]) {\n              continue\n            }\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            if (v[1] === null) {\n              delete op.attributes[v[0]]\n            } else {\n              op.attributes[v[0]] = v[1]\n            }\n          } else if (typeof v === 'string') {\n            op.insert.push(v)\n          } else { // v is embed (Object)\n            if (op.insert.length > 0) {\n              op.insert = op.insert.join('')\n              ops.push(op)\n              createNewOp()\n            }\n            op.insert = v\n            ops.push(op)\n            createNewOp()\n          }\n        }\n        if (op.insert.length > 0) {\n          op.insert = op.insert.join('')\n          ops.push(op)\n        }\n        ops.map(function (op) {\n          if (Object.keys(op.attributes).length === 0) {\n            delete op.attributes\n          }\n        })\n        return ops\n      }\n      insert (pos, content) {\n        var curPos = 0\n        var selection = {}\n        for (var i = 0; i < this._content.length; i++) {\n          if (curPos === pos) {\n            break\n          }\n          var v = this._content[i].val\n          if (v.constructor !== Array) {\n            curPos++\n          } else {\n            if (v[1] === null) {\n              delete selection[v[0]]\n            } else {\n              selection[v[0]] = v[1]\n            }\n          }\n        }\n        var ins\n        if (typeof content === 'string') {\n          ins = content.split('')\n        } else if (content.constructor === Object) {\n          ins = [content]\n        } else {\n          ins = content\n        }\n        super.insert(i, ins)\n        return selection\n      }\n      delete (pos, length) {\n        /*\n          let x = to be deleted string\n          let s = some string\n          let * = some selection\n          E.g.\n          sss*s***x*xxxxx***xx*x**ss*s\n               |---delete-range--|\n             delStart         delEnd\n\n          We'll check the following\n          * is it possible to delete some of the selections?\n            1. a dominating selection to the right could be the same as the selection (curSel) to delStart\n            2. a selections could be overwritten by another selection to the right\n        */\n        var curPos = 0\n        var curSel = {}\n        var endPos = pos + length\n        if (length <= 0) return\n        var delStart // relative to _content\n        var delEnd // ..\n        var v, i // helper variable for elements of _content\n\n        for (delStart = 0; curPos < pos && delStart < this._content.length; delStart++) {\n          v = this._content[delStart].val\n          if (v.constructor !== Array) {\n            curPos++\n          } else {\n            curSel[v[0]] = v[1]\n          }\n        }\n        for (delEnd = delStart; curPos < endPos && delEnd < this._content.length; delEnd++) {\n          v = this._content[delEnd].val\n          if (v.constructor !== Array) {\n            curPos++\n          }\n        }\n        if (delEnd === this._content.length) {\n          // yay, you can delete everything without checking\n          super.delete(delStart, delEnd - delStart)\n        } else {\n          if (v.constructor !== Array) {\n            delEnd--\n          }\n          var rightSel = {}\n          for (i = delEnd; i >= delStart; i--) {\n            v = this._content[i].val\n            if (v.constructor === Array) {\n              if (rightSel[v[0]] === undefined) {\n                if (v[1] === curSel[v[0]]) {\n                  // case 1.\n                  super.delete(i, 1)\n                }\n                rightSel[v[0]] = v[1]\n              } else {\n                // case 2.\n                super.delete(i, 1)\n              }\n            } else {\n              var end = i + 1\n              while (i > delStart) {\n                v = this._content[i - 1].val\n                if (v.constructor !== Array) {\n                  i--\n                } else {\n                  break\n                }\n              }\n              // always delete the strings\n              super.delete(i, end - i)\n            }\n          }\n        }\n      }\n      /*\n      1. get selection attributes from position $from\n         (name it antiAttrs, and we'll use it to make sure that selection ends in antiAttrs)\n      2. Insert selection $attr, if necessary\n      3. Between from and to, we'll delete all selections that do not match $attr.\n         Furthermore, we'll update antiAttrs, if necessary\n      4. In the end well insert a selection that makes sure that selection($to) ends in antiAttrs\n      */\n      select (from, to, attrName, attrValue) {\n        if (from == null || to == null || attrName == null || attrValue === undefined) {\n          throw new Error('You must define four parameters')\n        } else {\n          var step2i\n          var step2sel\n          var antiAttrs = [attrName, null]\n          var curPos = 0\n          var i = 0\n          // 1. compute antiAttrs\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === from) {\n              break\n            }\n            if (v.constructor === Array) {\n              // selection\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n              }\n            } else {\n              // embed or text\n              curPos++\n            }\n          }\n          // 2. Insert attr\n          if (antiAttrs[1] !== attrValue) {\n            // we'll execute this later\n            step2i = i\n            step2sel = [attrName, attrValue]\n          }\n\n          // 3. update antiAttrs, modify selection\n          var deletes = []\n          for (; i < this._content.length; i++) {\n            let v = this._content[i].val\n            if (curPos === to) {\n              break\n            }\n            if (v.constructor === Array) {\n              // selection\n              if (v[0] === attrName) {\n                antiAttrs[1] = v[1]\n                deletes.push(i)\n              }\n            } else {\n              // embed or text\n              curPos++\n            }\n          }\n          // actually delete the found selections\n          // also.. we have to delete from right to left (so that the positions dont change)\n          for (var j = deletes.length - 1; j >= 0; j--) {\n            var del = deletes[j]\n            super.delete(del, 1)\n            // update i, rel. to\n            if (del < i) {\n              i--\n            }\n            if (del < step2i) {\n              step2i--\n            }\n          }\n          // 4. Update selection to match antiAttrs\n          // never insert, if not necessary\n          //  1. when it is the last position ~ i < _content.length)\n          //  2. when a similar attrName already exists between i and the next character\n          if (antiAttrs[1] !== attrValue && i < this._content.length) { // check 1.\n            var performStep4 = true\n            var v\n            for (j = i; j < this._content.length; j++) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                performStep4 = false // check 2.\n                if (v[1] === attrValue) {\n                  super.delete(j, 1)\n                }\n                break\n              }\n            }\n            if (performStep4) {\n              var sel = [attrName, antiAttrs[1]]\n              super.insert(i, [sel])\n            }\n          }\n          if (step2i != null) {\n            super.insert(step2i, [step2sel])\n            // if there are some selections to the left of step2sel, delete them if possible\n            // * have same attribute name\n            // * no insert between step2sel and selection\n            for (j = step2i - 1; j >= 0; j--) {\n              v = this._content[j].val\n              if (v.constructor !== Array) {\n                break\n              }\n              if (v[0] === attrName) {\n                super.delete(j, 1)\n              }\n            }\n          }\n        }\n      }\n      /*\n        This method accepts a quill delta (http://quilljs.com/docs/deltas/)\n        The second parameter (_quill) is optional (it is only necessary when binding a quill instance)\n      */\n      applyDelta (delta, _quill) {\n        var pos = 0\n        var name // helper variable\n        for (var i = 0; i < delta.ops.length; i++) {\n          var op = delta.ops[i]\n          var attrs\n          var insLength\n          if (op.insert != null) {\n            if (typeof op.insert === 'string') {\n              attrs = this.insert(pos, op.insert)\n              insLength = op.insert.length\n            } else { // typeof is Object\n              attrs = this.insert(pos, op.insert)\n              insLength = 1\n            }\n            // create new selection\n            for (name in op.attributes) {\n              if (op.attributes[name] !== attrs[name]) {\n                this.select(pos, pos + insLength, name, op.attributes[name])\n              }\n            }\n            // not-existence of an attribute in op.attributes denotes\n            // that we have to unselect (set to null)\n            for (name in attrs) {\n              if (op.attributes == null || attrs[name] !== op.attributes[name]) {\n                this.select(pos, pos + insLength, name, null)\n              }\n            }\n            pos += insLength\n          }\n          if (op.delete != null) {\n            this.delete(pos, op.delete)\n          }\n          if (op.retain != null && _quill != null) {\n            var afterRetain = pos + op.retain\n            if (afterRetain > this.length) {\n              // debugger // TODO: check why this is still called..\n              let additionalContent = _quill.getText(this.length)\n              _quill.insertText(this.length, additionalContent)\n              // quill.deleteText(this.length + additionalContent.length, quill.getLength()) the api changed!\n              for (name in op.attributes) {\n                // TODO: format expects falsy values now in order to remove formats\n                _quill.formatText(this.length + additionalContent.length, additionalContent.length, name, null)\n                // quill.deleteText(this.length, this.length + op.retain) the api changed!\n              }\n              this.insert(this.length, additionalContent)\n              // op.attributes = null\n            }\n            for (name in op.attributes) {\n              var attr = op.attributes[name]\n              this.select(pos, pos + op.retain, name, attr)\n              // TODO: check if attr is `false` sometimes.. (then you need to adapt the algorithm)\n              _quill.formatText(pos, op.retain, name, attr == null ? false : attr) // use correct values here (changed in quill@1.0)\n            }\n            pos = afterRetain\n          }\n        }\n      }\n      bind () {\n        this.bindQuill.apply(this, arguments)\n      }\n      unbindQuill (quill) {\n        var i = this.instances.findIndex(function (binding) {\n          return binding.editor === quill\n        })\n        if (i >= 0) {\n          var binding = this.instances[i]\n          this.unobserve(binding.yCallback)\n          binding.editor.off('text-change', binding.quillCallback)\n          this.instances.splice(i, 1)\n        }\n      }\n      bindQuill (quill) {\n        var self = this\n\n        // this function makes sure that either the\n        // quill event is executed, or the yjs observer is executed\n        var token = true\n        function mutualExcluse (f) {\n          if (token) {\n            token = false\n            try {\n              f()\n            } catch (e) {\n              token = true\n              throw new Error(e)\n            }\n            token = true\n          }\n        }\n        quill.setContents(this.toDelta())\n\n        function quillCallback (delta) {\n          mutualExcluse(function () {\n            self.applyDelta(delta, quill)\n          })\n        }\n        quill.on('text-change', quillCallback)\n\n        function yCallback (event) {\n          mutualExcluse(function () {\n            var v // helper variable\n            var curSel // helper variable (current selection)\n            if (event.type === 'insert') {\n              var _value_i = 0\n              while (_value_i < event.values.length) {\n                var vals = []\n                while (_value_i < event.values.length && event.values[_value_i].constructor !== Array) {\n                  vals.push(event.values[_value_i])\n                  _value_i++\n                }\n                if (vals.length > 0) { // insert new content (text and embed)\n                  var position = 0\n                  var insertSel = {}\n                  for (var l = 0; l < event.index; l++) {\n                    v = self._content[l].val\n                    if (v.constructor !== Array) {\n                      position++\n                    } else {\n                      insertSel[v[0]] = v[1]\n                    }\n                  }\n                  // consider the case (this is markup): \"hi *you*\" & insert \"d\" at position 3\n                  // Quill may implicitely make \"d\" bold (dunno if thats true). Yjs, however, expects d not to be bold.\n                  // So we check future attributes and explicitely set them, if neccessary\n                  l = event.index + event.length\n                  while (l < self._content.length) {\n                    v = self._content[l].val\n                    if (v.constructor === Array) {\n                      if (!insertSel.hasOwnProperty(v[0])) {\n                        insertSel[v[0]] = null\n                      }\n                    } else {\n                      break\n                    }\n                    l++\n                  }\n                  // TODO: you definitely should exchange null with the new \"false\" approach..\n                  // Then remove the following! :\n                  for (var name in insertSel) {\n                    if (insertSel[name] == null) {\n                      insertSel[name] = false\n                    }\n                  }\n                  if (self.length === position + vals.length && vals[vals.length - 1] !== '\\n') {\n                    // always make sure that the last character is enter!\n                    var end = ['\\n']\n                    var sel = {}\n                    // now we remove all selections\n                    for (name in insertSel) {\n                      if (insertSel[name] !== false) {\n                        end.unshift([name, false])\n                        sel[name] = false\n                      }\n                    }\n                    Y.Array.typeDefinition.class.prototype.insert.call(self, position + vals.length, end)\n                    quill.insertText(position, '\\n', sel)\n                  }\n                  // create delta from vals\n                  var delta = []\n                  if (position > 0) {\n                    delta.push({ retain: position })\n                  }\n                  var currText = []\n                  vals.forEach(function (v) {\n                    if (typeof v === 'string') {\n                      currText.push(v)\n                    } else {\n                      if (currText.length > 0) {\n                        delta.push({\n                          insert: currText.join(''),\n                          attributes: insertSel\n                        })\n                        currText = []\n                      }\n                      delta.push({\n                        insert: v,\n                        attributes: insertSel\n                      })\n                    }\n                  })\n                  if (currText.length > 0) {\n                    delta.push({\n                      insert: currText.join(''),\n                      attributes: insertSel\n                    })\n                  }\n                  quill.updateContents(delta)\n                  // quill.insertText(position, vals.join(''), insertSel)\n                } else { // Array (selection)\n                  // a new selection is created\n                  // find left selection that matches newSel[0]\n                  curSel = null\n                  var newSel = event.values[_value_i++] // get selection, increment counter\n                  // denotes the start position of the selection\n                  // (without the selection objects)\n                  var selectionStart = 0\n                  for (var j = event.index + _value_i - 2/* -1 for index, -1 for incremented _value_i*/; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor === Array) {\n                      // check if v matches newSel\n                      if (newSel[0] === v[0]) {\n                        // found a selection\n                        // update curSel and go to next step\n                        curSel = v[1]\n                        break\n                      }\n                    } else {\n                      selectionStart++\n                    }\n                  }\n                  // make sure to decrement j, so we correctly compute selectionStart\n                  for (; j >= 0; j--) {\n                    v = self._content[j].val\n                    if (v.constructor !== Array) {\n                      selectionStart++\n                    }\n                  }\n                  // either a selection was found {then curSel was updated}, or not (then curSel = null)\n                  if (newSel[1] === curSel) {\n                    // both are the same. not necessary to do anything\n                    continue\n                  }\n                  // now find out the range over which newSel has to be created\n                  var selectionEnd = selectionStart\n                  for (var k = event.index + _value_i/* -1 for incremented _value_i, +1 for algorithm */; k < self._content.length; k++) {\n                    v = self._content[k].val\n                    if (v.constructor === Array) {\n                      if (v[0] === newSel[0]) {\n                        // found another selection with same attr name\n                        break\n                      }\n                    } else {\n                      selectionEnd++\n                    }\n                  }\n                  // create a selection from selectionStart to selectionEnd\n                  if (selectionStart !== selectionEnd) {\n                    // TODO: check if attr is `false` sometimes.. (then you need to adapt the algorithm)\n                    quill.formatText(selectionStart, selectionEnd - selectionStart, newSel[0], newSel[1] == null ? false : newSel[1])\n                  }\n                }\n              }\n            } else if (event.type === 'delete') {\n              // sanitize events\n              var myEvents = []\n              for (var i = 0, _i = 0; i < event.length; i++) {\n                if (event.values[i].constructor === Array) {\n                  if (i !== _i) {\n                    myEvents.push({\n                      type: 'text',\n                      length: i - _i,\n                      index: event.index\n                    })\n                  }\n                  _i = i + 1\n                  myEvents.push({\n                    type: 'selection',\n                    val: event.values[i],\n                    index: event.index\n                  })\n                }\n              }\n              if (i !== _i) {\n                myEvents.push({\n                  type: 'text',\n                  length: i - _i,\n                  index: event.index\n                })\n              }\n              // ending sanitizing.. start brainfuck\n              myEvents.forEach(event => {\n                if (event.type === 'text') {\n                  var pos = 0\n                  for (var u = 0; u < event.index; u++) {\n                    v = self._content[u].val\n                    if (v.constructor !== Array) {\n                      pos++\n                    }\n                  }\n                  quill.deleteText(pos, event.length)\n                } else {\n                  curSel = null\n                  var from = 0\n                  var x\n                  for (x = event.index - 1; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) {\n                        curSel = v[1]\n                        break\n                      }\n                    } else {\n                      from++\n                    }\n                  }\n                  for (; x >= 0; x--) {\n                    v = self._content[x].val\n                    if (v.constructor !== Array) {\n                      from++\n                    }\n                  }\n                  var to = from\n                  for (x = event.index; x < self._content.length; x++) {\n                    v = self._content[x].val\n                    if (v.constructor === Array) {\n                      if (v[0] === event.val[0]) {\n                        break\n                      }\n                    } else {\n                      to++\n                    }\n                  }\n                  if (curSel !== event.val[1] && from !== to) {\n                    // TODO: check if attr is `false` sometimes.. (then you need to adapt the algorithm)\n                    quill.formatText(from, to - from, event.val[0], curSel == null ? false : curSel)\n                  }\n                }\n              })\n            }\n            quill.update()\n          })\n        }\n        this.observe(yCallback)\n        this.instances.push({\n          editor: quill,\n          yCallback: yCallback,\n          quillCallback: quillCallback\n        })\n      }\n    }\n    Y.extend('Richtext', new Y.utils.CustomType({\n      name: 'Richtext',\n      class: YRichtext,\n      struct: 'List',\n      initType: function * YTextInitializer (os, model) {\n        var _content = []\n        yield* Y.Struct.List.map.call(this, model, function (op) {\n          if (op.hasOwnProperty('opContent')) {\n            throw new Error('Text must not contain types!')\n          } else {\n            op.content.forEach(function (c, i) {\n              _content.push({\n                id: [op.id[0], op.id[1] + i],\n                val: op.content[i]\n              })\n            })\n          }\n        })\n        return new YRichtext(os, model.id, _content)\n      }\n    }))\n  })\n}\n\nmodule.exports = extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n",null],"sourceRoot":"/source/"}